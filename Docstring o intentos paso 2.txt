// 2.1)
// Función para almacenar los datos de amplitud en un arreglo dinámico
// Esta función genera valores y los almacena en un arreglo dinámico. Si el arreglo se llena, se redimensiona para acomodar más datos. 
// Al final, imprime los datos almacenados y libera la memoria utilizada.

void almacenarDatos(float* datos, int& numDatos) {
    if (arreglo == nullptr) {
        cerr << "Error al asignar memoria" << endl;
        return 1;
    int capacidad = 10;
    int elementos = 0;
    float* arreglo = new float[capacidad];
    
    int i = 0;
    while(true){
        float valor = generarValor(i);
        if (numElementos == capacidad){
            capacidad *= 2;
            float* nuevoArreglo = new float[capacidad];
            for (int j = 0; j < numElemntos; j++){
                nuevoArreglo[j] = arreglo[j];                
            }
            delete[] arreglo;
            arreglo = nuevoArreglo;
            
        }
        
        arreglo[numElementos] = valor;
        numElementos++;
        
        if(numElementos >= 100) break;
        
        i++;
    }
    cout << "Datos almacenados: ";
    for (int i = 0; i < numElementos; i++){
        cout << arreglo[i] << " ";
    }
    cout << endl;
        
    delete[] arreglo;
    
    return 0;
}
    // Leer datos del sensor o simulador
    // Almacenar los datos en el arreglo dinámico
}

// 2.2)
// Función para calcular la frecuencia y duración de un ciclo usando cruces por cero
// Esta función cuenta los cruces por cero en las muestras para estimar la frecuencia de la señal. 
// Utiliza el número total de muestras y el tiempo total para calcular la frecuencia y la duración de un ciclo completo.

void calcularFrecuenciaYCiclos(double* muestras, int numMuestras, double tiempoTotal) {
    int crucesPorCero = 0;
    int muestrasPorCiclo = 0;
    bool encontradoPrimerCiclo = false;

    for (int i = 1; i < numMuestras; i++) {
        if ((muestras[i - 1] > 0 && muestras[i] < 0) || (muestras[i - 1] < 0 && muestras[i] > 0)) {
            crucesPorCero++;
            if (!encontradoPrimerCiclo) {
                muestrasPorCiclo = i;  // Primer ciclo completo detectado
                encontradoPrimerCiclo = true;
            }
        }
    }

    double ciclos = crucesPorCero / 2.0;
    double frecuencia = ciclos / tiempoTotal;

    if (encontradoPrimerCiclo) {
        cout << "Frecuencia estimada: " << frecuencia << " Hz" << endl;
        cout << "Duración de un ciclo: " << (muestrasPorCiclo * tiempoTotal / numMuestras) << " segundos" << endl;
    } else {
        cout << "No se detectaron suficientes ciclos." << endl;
    }
}


// 2.3)
// Función para calcular los valores máximos y mínimos de la amplitud
// Esta función recorre los datos para encontrar los valores máximo y mínimo de la amplitud. 
// Los valores máximo y mínimo se retornan por referencia para su posterior uso.

float calcularAmplitud() {
  float valorMaximo = 3.402823466e+38; // Mayor valor posible para un float
  float valorMinimo = -3.402823466e+38; // Menor valor posible para un float

  for (int i = 0; i < numDatos; i++) {
    if (datos[i] > valorMaximo) {
      valorMaximo = datos[i];
    }
    if (datos[i] < valorMinimo) {
      valorMinimo = datos[i];
    }
  }

    //Hacer un return con ambos valores. 
}
    // Implementar un algoritmo para calcular la frecuencia
    // Por ejemplo, usando la transformada de Fourier o contando cruces por cero
}

// 2.4)
// Función para identificar la forma de la onda y definir los patrones de las ondas
// Esta función determina si la señal es senoidal, cuadrada o triangular basándose en el patrón de cambios en las muestras. 
// Los datos son normalizados en función de la amplitud máxima antes de la identificación de la forma de la onda.

void definirPatrones() {
    // Crear estructuras de datos para representar los patrones (por ejemplo, arreglos)
    // Vamos a usar un arreglo de estructuras para almacenar información como:
    // - Nombre de la onda
    // - Valores de referencia para amplitud, frecuencia, pendiente, etc.
    // - Un arreglo de valores que represente un ciclo completo de la onda
void normalizarMuestras(double* muestras, int numMuestras, double amplitudMax) {
    for (int i = 0; i < numMuestras; i++) {
        muestras[i] /= amplitudMax;  // Normalizar con respecto a la amplitud máxima
    }
}

// Función para determinar si la señal es senoidal, cuadrada o triangular
void determinarTipoOnda(double* muestras, int numMuestras) {
    bool esSenoidal = true;
    bool esCuadrada = true;
    bool esTriangular = true;

    for (int i = 1; i < numMuestras; i++) {
        double diferencia = fabs(muestras[i] - muestras[i - 1]);

        // Onda senoidal: cambios suaves
        if (diferencia > 0.5) {
            esSenoidal = false;
        }

        // Onda cuadrada: cambios abruptos entre niveles alto y bajo
        if (diferencia < 1.0) {
            esCuadrada = false;
        }

        // Onda triangular: cambios constantes entre los valores
        if (i > 1) {
            double diferenciaPrev = fabs(muestras[i - 1] - muestras[i - 2]);
            if (fabs(diferencia - diferenciaPrev) > 0.1) {
                esTriangular = false;
            }
        }
    }

    // Determinar el tipo de onda
    if (esSenoidal) {
        cout << "La función es Senoidal." << endl;
    } else if (esCuadrada) {
        cout << "La función es Cuadrada." << endl;
    } else if (esTriangular) {
        cout << "La función es Triangular." << endl;
    } else {
        cout << "No se pudo determinar el tipo de onda." << endl;
    }
}
}
    // Comparar los datos medidos con los patrones predefinidos
    // Calcular la similitud (correlación)
    // Retornar el nombre de la onda más parecido
//2.5)
// Función para imprimir los resultados en pantalla
    // Utilizar la librería LCD para mostrar los resultados en pantalla
